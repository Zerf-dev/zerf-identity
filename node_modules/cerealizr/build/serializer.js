"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("./utils");

var _serializerError = _interopRequireDefault(require("./serializerError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Serializer =
/*#__PURE__*/
function () {
  function Serializer(_ref) {
    var descriptor = _ref.descriptor,
        _ref$defaultTransform = _ref.defaultTransform,
        defaultTransform = _ref$defaultTransform === void 0 ? function (key, value) {
      return _defineProperty({}, key, value);
    } : _ref$defaultTransform,
        _ref$mapAllValues = _ref.mapAllValues,
        mapAllValues = _ref$mapAllValues === void 0 ? false : _ref$mapAllValues;

    _classCallCheck(this, Serializer);

    this.descriptor = descriptor;
    this.mapAllValues = mapAllValues;
    this.defaultTransform = defaultTransform;
  }

  _createClass(Serializer, [{
    key: "checkValidValue",
    value: function checkValidValue(field) {
      if (field === null || _typeof(field) !== 'object' || Object.keys(field).length > 1) {
        throw new _serializerError.default("Serializer mapper function values must return an non null object with only one key, instead found: ".concat(field));
      }
    }
  }, {
    key: "getTransformedField",
    value: function getTransformedField(transform, key, value) {
      return transform(key, value);
    }
  }, {
    key: "transformWithFunction",
    value: function transformWithFunction(object, transform, key, value) {
      var newField = this.getTransformedField(transform, key, value);
      this.checkValidValue(newField);
      return Object.assign({}, object, newField);
    }
  }, {
    key: "transformWithString",
    value: function transformWithString(object, string, value) {
      object[string] = value;
    }
  }, {
    key: "serialize",
    value: function serialize(element) {
      var _this = this;

      if ((0, _utils.isArray)(element)) {
        return element.map(function (innerElement) {
          return _this.serialize(innerElement);
        });
      }

      if (!(0, _utils.isNonArrayObject)(element)) {
        return element;
      }

      return Object.keys(element).reduce(function (accumulator, key) {
        var value = element[key];
        var transform = _this.descriptor && _this.descriptor[key]; // If no transform is given, it'll only return the key when this.mapAllValues = true

        if (transform === undefined) {
          if (_this.mapAllValues) {
            return _this.transformWithFunction(accumulator, _this.defaultTransform, key, value);
          } else {
            return accumulator;
          }
        }

        if (typeof transform === 'function') {
          return _this.transformWithFunction(accumulator, transform, key, value);
        } else if (typeof transform === 'string') {
          _this.transformWithString(accumulator, transform, value);
        } else {
          throw new _serializerError.default("Serializer mapper values must be either a string or a function, instead found: ".concat(_typeof(transform)));
        }

        return accumulator;
      }, {});
    }
  }]);

  return Serializer;
}();

var _default = Serializer;
exports.default = _default;